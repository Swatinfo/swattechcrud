Collecting workspace information```markdown
# Relationship Management

This guide explains how SwatTech CRUD handles, detects, and generates code for database relationships in your Laravel application.

## Supported Relationship Types

The package supports all Laravel Eloquent relationship types:

### Standard Relationships

| Type | Description | Database Structure |
|------|-------------|-------------------|
| `belongsTo` | A model belongs to another model | Foreign key in current table |
| `hasMany` | A model has many related models | Foreign key in related table |
| `hasOne` | A model has one related model | Foreign key in related table |
| `belongsToMany` | Many-to-many relationship | Requires pivot table |

### Polymorphic Relationships

| Type | Description | Database Structure |
|------|-------------|-------------------|
| `morphTo` | Model belongs to multiple model types | `{name}_type` and `{name}_id` columns |
| `morphOne` | One-to-one polymorphic relation | Foreign type and ID columns in related table |
| `morphMany` | One-to-many polymorphic relation | Foreign type and ID columns in related table |
| `morphToMany` | Many-to-many polymorphic relation | Requires pivot table with polymorphic columns |
| `morphedByMany` | Inverse of morphToMany | Requires pivot table with polymorphic columns |

## Relationship Detection Process

SwatTech CRUD automatically detects relationships from your database structure using the following process:

1. **Schema Analysis**: Analyzes table columns, indices, and foreign keys
2. **Foreign Key Detection**: Identifies foreign key columns following naming conventions
3. **Pivot Table Recognition**: Detects potential pivot tables for many-to-many relationships
4. **Polymorphic Column Detection**: Identifies `*_type` and `*_id` column pairs
5. **Relationship Mapping**: Maps detected relationships to appropriate Eloquent methods

The detection process is handled by specialized analyzers for each relationship type, coordinated by a master `RelationshipAnalyzer`.

```bash
php artisan crud:relationships users
```

The above command will analyze and generate relationship code for the `users` table.

## Custom Relationship Configuration

While automatic detection works well for standard conventions, you can configure custom relationships in the `config/crud.php` file:

```php
'relationships' => [
    'detect' => true,
    'foreign_key_pattern' => '{table}_id',
    'polymorphic_pattern' => '{name}able',
    'custom_naming' => [
        'users' => [
            'authored_posts' => 'posts:user_id,author_id',
            'favorited_posts' => 'posts:pivot,user_favorites,user_id,post_id',
        ],
    ],
],
```

### Custom Relationship Format

Custom relationships follow these format patterns:

1. **Direct foreign key**: `table:local_key,foreign_key`
2. **Pivot table**: `table:pivot,pivot_table,local_key,related_key`
3. **Polymorphic**: `table:morph,morph_name,type`

You can also define relationships directly when generating:

```bash
php artisan crud:relationships users --belongs-to="roles" --has-many="posts:author_id"
```

## Polymorphic Relationship Handling

Polymorphic relationships require special handling due to their complex nature. The package provides specific features for polymorphic relationships:

### Morph Map Generation

```php
// The package can generate a MorphMapTrait
\Illuminate\Database\Eloquent\Relations\Relation::morphMap([
    'post' => App\Models\Post::class,
    'video' => App\Models\Video::class,
]);
```

### Polymorphic Controllers

The package generates specialized controllers for polymorphic relationships that handle the complexity of multiple model types.

### Polymorphic Forms

For UI interaction, specialized form components are generated to handle polymorphic relationships, including:
- Type selection dropdowns
- Dynamic fields based on the selected type
- Proper validation for each type

## Example Relationship Configurations

### Standard Has-Many Relationship

```php
// Model code generated by the package
public function posts()
{
    return $this->hasMany(\App\Models\Post::class, 'user_id', 'id');
}
```

### Custom Named Relationship

```php
// Custom relationship with non-standard key
public function authoredPosts()
{
    return $this->hasMany(\App\Models\Post::class, 'author_id', 'id');
}
```

### Many-to-Many with Pivot Data

```php
// Many-to-many with pivot attributes
public function roles()
{
    return $this->belongsToMany(\App\Models\Role::class, 'role_user', 'user_id', 'role_id')
        ->withTimestamps()
        ->withPivot(['active', 'expires_at']);
}
```

### Polymorphic Relationship

```php
// Polymorphic relationship
public function comments()
{
    return $this->morphMany(\App\Models\Comment::class, 'commentable');
}
```

## Troubleshooting Relationship Issues

### Common Issues and Solutions

| Issue | Possible Cause | Solution |
|-------|---------------|----------|
| Relationship not detected | Non-standard naming | Add custom relationship in config |
| Wrong relationship type | Ambiguous database structure | Use specific relationship type flags |
| Missing pivot table | Table not following convention | Create or rename pivot table properly |
| Polymorphic relationship issues | Missing type column | Ensure both `*_type` and `*_id` columns exist |

### Diagnostic Commands

```bash
# Show all detected relationships
php artisan crud:relationships users --dry-run

# Check database structure
php artisan db:table users
```

## Naming Convention Documentation

SwatTech CRUD follows these naming conventions for relationships:

### Table Naming

- Singular or plural table names are supported (e.g., `user` or `users`)
- Pivot tables should be named using singular model names in alphabetical order (e.g., `role_user`)

### Foreign Key Naming

- Foreign keys should follow `{table_singular}_id` format (e.g., `user_id`)
- Custom foreign keys can be configured in the settings

### Relationship Method Naming

- `belongsTo`: Singular related model name (e.g., `user()`)
- `hasMany`: Plural related model name (e.g., `posts()`)
- `hasOne`: Singular related model name (e.g., `profile()`)
- `belongsToMany`: Plural related model name (e.g., `roles()`)
- `morphTo`: Camel case of morph name (e.g., `commentable()`)
- `morphMany`: Plural related model name (e.g., `comments()`)

## Validation Rule Generation for Relationships

The package automatically generates appropriate validation rules for relationships:

### Standard Validation Rules

```php
// belongsTo relationship validation
'user_id' => 'required|exists:users,id',

// belongsToMany relationship validation
'role_ids.*' => 'exists:roles,id',

// hasMany/hasOne relationship validation is handled when saving the related models
```

### Polymorphic Validation Rules

```php
// morphTo validation
'commentable_id' => 'required',
'commentable_type' => 'required|string|in:App\\Models\\Post,App\\Models\\Video',

// morphToMany validation
'taggables.*' => 'exists:tags,id',
```

## UI Handling for Relationship Forms

The package generates specialized form components for each relationship type:

### BelongsTo Relationship Form

```blade
<div class="form-group">
    <label for="user_id">User</label>
    <select name="user_id" class="form-control">
        @foreach($users as $user)
            <option value="{{ $user->id }}" {{ $post->user_id == $user->id ? 'selected' : '' }}>
                {{ $user->name }}
            </option>
        @endforeach
    </select>
</div>
```

### BelongsToMany Relationship Form

```blade
<div class="form-group">
    <label>Tags</label>
    <select name="tags[]" class="form-control" multiple>
        @foreach($tags as $tag)
            <option value="{{ $tag->id }}" {{ $post->tags->contains($tag->id) ? 'selected' : '' }}>
                {{ $tag->name }}
            </option>
        @endforeach
    </select>
</div>
```

### Polymorphic Form Components

For polymorphic relationships, the package generates specialized components:

1. Type selection dropdown
2. Dynamic ID selection based on selected type
3. Live preview of selected items
4. Add/remove functionality for multiple relationships

## Advanced Relationship Scenarios

### Nested Resources

The package can generate nested resource controllers for parent-child relationships:

```php
// Generated route in web.php
Route::resource('users.posts', UserPostController::class);

// Generated controller handles the relationship
class UserPostController extends Controller
{
    public function index(User $user)
    {
        return view('posts.index', [
            'posts' => $user->posts()->paginate(),
            'user' => $user
        ]);
    }
    
    // Other methods...
}
```

### Self-Referential Relationships

You can define self-referential relationships like hierarchical structures:

```php
// Example in config/crud.php
'custom_naming' => [
    'categories' => [
        'children' => 'categories:parent_id,id',
        'parent' => 'categories:id,parent_id:belongsTo',
    ],
],
```

### Many-to-Many with Extra Pivot Data

For pivot tables with additional data:

```php
// Configuration
'custom_naming' => [
    'users' => [
        'projects' => 'projects:pivot,project_user,user_id,project_id:timestamps:withPivot:role,access_level',
    ],
],
```

### Conditional Relationships

```php
// Generated scope
public function scopeWithActiveSubscription($query)
{
    return $query->whereHas('subscriptions', function($q) {
        $q->where('active', true)->where('expires_at', '>', now());
    });
}
```

### Lazy/Eager Loading Control

The package implements optimal loading strategies:

```php
// Generated index method with relationship loading
public function index(Request $request)
{
    $users = User::with(['posts', 'profile', 'roles'])
        ->withCount('posts')
        ->paginate();
        
    return view('users.index', compact('users'));
}
```

## Running the Relationship Generator

Generate all relationship features for a table:

```bash
php artisan crud:relationships users --controllers --routes --forms --validation
```

Focus on specific relationship types:

```bash
php artisan crud:relationships users --belongs-to --has-many
```

Process all tables:

```bash
php artisan crud:relationships --all
```

See detailed options:

```bash
php artisan crud:relationships --help
```

For comprehensive documentation integration, you can also generate documentation for your relationships:

```bash
php artisan crud:docs users --relationships
```